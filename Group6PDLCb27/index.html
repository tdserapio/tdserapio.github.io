Hello traveller! 

You may be here because you are checking out my âœ¨ awesome âœ¨ PDLC group project. <br>
The person who made this website (actually his main personal website is at <a href="https://tdserapio.github.io">here</a> check it out its very cool) <br>
And you may probably be looking for the source code file... <br><br>

It should be this: <a href="tdserapio.github.io/Group6PDLCb27/">here!</a> <br><br>

# Empty Array declaration
<br>events = []
<br>joined = []
<br>
<br># Variable Initialization/Declaration
<br>num_events = int(input("Number of events? "))
<br>print(
<br>    "\n-------------\nWhen inputting in seconds format:\nThe start, and end of the event in this format without brackets: [start end]. \nFor instance, if the earliest event starts at 6:00PM, then that shall be marked as the 0th second. Then, say for instance 6:10 would be 600 seconds after the first event. Therefore, you shall input that as 600.\n-------------\n"
<br>)
<br>counter = 0
<br>
<br># Input Loop
<br>while counter < num_events:
<br>    # Get name of event
<br>    name = input("What is the name of this event? ")
<br>
<br>    # Processing input of seconds
<br>    seconds = input("The 'time' of this event in seconds format? ")
<br>    seconds = seconds.split(" ")
<br>    curr_event_start = int(seconds[0])
<br>    curr_event_end = int(seconds[1])
<br>
<br>    # Simply append it to array
<br>
<br>    events.append([name, curr_event_start, curr_event_end])
<br>
<br>    # Counter
<br>    counter += 1
<br>    print()
<br>
<br># Sort the array
<br>
<br>events = sorted(events, key=lambda x: x[2])
<br>
<br># Processing Loop
<br>
<br>while events:
<br>    # Since array is already sorted, we simply need to get the first element to get the one with the earliest end time.
<br>    curr_min = events[0]
<br>
<br>    # This is automatically an event that we shall join.
<br>    joined.append(curr_min)
<br>
<br>    # Make another array to store the events that are not yet omitted. Although this might cause a Memory problem with very large inputs, I do not have enough brain power to think of something better.
<br>    # If I do it in the array itself the indexes may overflow and it simply would just be many more weird processing stuff i guess
<br>    new_events_array = []
<br>
<br>    # Loop through the events to see which ones to omit and which ones to not
<br>    for i in range(len(events)):
<br>        # Although there is a much more efficient and more flexible and simple method, I decided to just literally check whether the events collide with each other. Besides, I think sets are quite fast.
<br>        if len(
<br>                set(range(curr_min[1], curr_min[2])).intersection(
<br>                    set(range(events[i][1], events[i][2])))) == 0:
<br>            # If it doesn't well, collide, don't omit it just yet
<br>            new_events_array.append(events[i])
<br>    # The new events array is now only filled with non-omitted stuff
<br>    events = new_events_array
<br>
<br># Output it quite nicely ðŸ˜Œ
<br>print("-------------")
<br>print("You should join the following events:")
<br>for i in joined:
<br>    print(f"\n- Event name: {i[0]}")
<br>    print(
<br>        f"  This event shall happen between (in seconds format): {i[1]} until {i[2]}"
<br>    )
<br>print("\n")
